<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Dirac Belt Trick / ç‹„æ‹‰å…‹å¸¦å­å®éªŒæ¼”ç¤º</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: white; }
        #container { width: 100vw; height: 100vh; }
        #ui-layer {
            position: absolute; top: 20px; left: 20px; width: 320px;
            background: rgba(0, 0, 0, 0.8); padding: 20px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); pointer-events: auto;
        }
        h1 { margin: 0 0 10px 0; font-size: 18px; color: #4db8ff; }
        p { font-size: 13px; color: #ccc; line-height: 1.5; margin-bottom: 15px; }
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; color: #aaa; }
        input[type=range] { width: 100%; cursor: pointer; }
        .btn {
            background: #e74c3c; color: white; border: none; padding: 10px 20px;
            width: 100%; border-radius: 4px; cursor: pointer; font-size: 14px;
            transition: background 0.3s;
        }
        .btn:disabled { background: #555; cursor: not-allowed; }
        .btn:hover:not(:disabled) { background: #ff6b6b; }
        .status { font-family: monospace; color: #0f0; margin-top: 5px; font-size: 12px; }
        #note { margin-top: 10px; font-size: 11px; color: #888; font-style: italic; border-top: 1px solid #444; padding-top: 10px;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui-layer">
    <h1>Dirac Belt Trick (ç‹„æ‹‰å…‹å¸¦å­)</h1>
    <p>
        æ­¤æ¼”ç¤ºå±•ç¤ºäº† SO(3) æ—‹è½¬ç¾¤çš„æ‹“æ‰‘æ€§è´¨ã€‚
        <br><br>
        1. <b>æ‹–åŠ¨æ»‘å—</b>æ—‹è½¬å³ä¾§æ–¹å—ã€‚
        <br>
        2. <b>360Â° (2Ï€)</b>ï¼šå¸¦å­æ‰­æ›²ï¼Œä¸å¯ç›´æ¥è§£å¼€ã€‚
        <br>
        3. <b>720Â° (4Ï€)</b>ï¼šå¸¦å­çœ‹èµ·æ¥æ›´æ‰­äº†ï¼Œä½†åœ¨æ‹“æ‰‘ä¸Šç­‰ä»·äºæ²¡æœ‰æ‰­æ›²ã€‚ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®è§è¯å¥‡è¿¹ã€‚
    </p>
    
    <div class="control-group">
        <label>æ—‹è½¬è§’åº¦: <span id="angle-display">0</span>Â°</label>
        <input type="range" id="angle-slider" min="0" max="720" value="0" step="1">
    </div>

    <button id="untangle-btn" class="btn" disabled>ğŸ”’ éœ€æ—‹è½¬è‡³ 720Â° è§£é”è¿˜åŸæ¼”ç¤º</button>
    <div id="anim-status" class="status"></div>

    <div id="note">
        ç‰©ç†æ„ä¹‰ï¼šç”µå­è‡ªæ—‹æ˜¯ 1/2ï¼Œæ„å‘³ç€å®ƒçš„æ³¢å‡½æ•°åœ¨æ—‹è½¬ 360Â° åä¼šå˜å·ï¼ˆå¸¦å­æ‰­æ›²ï¼‰ï¼Œåªæœ‰æ—‹è½¬ 720Â° åæ‰èƒ½å®Œå…¨å¤åŸã€‚
    </div>
</div>

<div id="container"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- åœºæ™¯è®¾ç½® ---
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);
    scene.fog = new THREE.Fog(0x222222, 10, 50);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 4, 8);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    // --- ç¯å…‰ ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- å¯¹è±¡åˆ›å»º ---
    
    // 1. å›ºå®šç«¯ (å·¦ä¾§)
    const boxGeo = new THREE.BoxGeometry(1, 1, 1);
    const boxMatFixed = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.4 });
    const fixedBox = new THREE.Mesh(boxGeo, boxMatFixed);
    fixedBox.position.set(-3, 0, 0);
    fixedBox.castShadow = true;
    scene.add(fixedBox);

    // 2. æ—‹è½¬ç«¯ (å³ä¾§)
    const boxMatRot = new THREE.MeshStandardMaterial({ color: 0xffaa00, roughness: 0.4 });
    const rotatingBox = new THREE.Mesh(boxGeo, boxMatRot);
    rotatingBox.position.set(3, 0, 0);
    rotatingBox.castShadow = true;
    scene.add(rotatingBox);

    // 3. å¸¦å­ (The Belt)
    // ä½¿ç”¨ PlaneGeometryï¼Œä¸ºäº†å¹³æ»‘æ‰­æ›²ï¼Œæˆ‘ä»¬éœ€è¦å¾ˆå¤šåˆ†æ®µ (segments)
    const segments = 200;
    const beltLength = 6;
    const beltWidth = 0.8;
    const beltGeo = new THREE.PlaneGeometry(beltLength, beltWidth, segments, 1);
    
    // åˆ›å»ºåŒé¢æè´¨çš„æŠ€å·§ï¼šä½¿ç”¨ ShaderMaterial æˆ–è€…ç®€å•çš„çº¹ç†
    // ä¸ºäº†åŒºåˆ†æ­£åé¢ï¼Œæˆ‘ä»¬æ‰‹åŠ¨ç»™é¡¶ç‚¹ç€è‰²æˆ–è€…ä½¿ç”¨çº¹ç†ã€‚è¿™é‡Œä¸ºäº†ç®€å•ä¸”æ•ˆæœå¥½ï¼Œç”¨ä¸åŒçš„é¢œè‰²æ¸²æŸ“æ­£åé¢ã€‚
    // ç”±äº ThreeJS ä¸€ä¸ª Mesh åªèƒ½æœ‰ä¸€ä¸ª side å±æ€§ï¼Œæˆ‘ä»¬åˆ›å»ºä¸¤ä¸ª Mesh è´´åœ¨ä¸€èµ·ï¼Œæˆ–è€…ä½¿ç”¨ vertex colorsã€‚
    // è¿™é‡Œä½¿ç”¨æœ€ç®€å•çš„æ–¹æ³•ï¼šæ ¹æ®æ³•çº¿æ–¹å‘æŸ“è‰²ï¼ˆé«˜çº§ï¼‰ï¼Œæˆ–è€…ç›´æ¥ç”¨å¸¦çº¹ç†çš„æè´¨ã€‚
    
    // è®©æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªç®€å•çš„çº¹ç†ï¼šä¸ŠåŠéƒ¨åˆ†è“è‰²ï¼Œä¸‹åŠéƒ¨åˆ†çº¢è‰²ï¼Œç”¨æ¥æ¨¡æ‹Ÿæ­£åé¢
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#4488ff'; // æ­£é¢è“
    ctx.fillRect(0,0,64,64);
    
    // å®é™…ä¸Šï¼ŒPlaneGeometry çš„ UV æ˜ å°„ä½¿å¾—æˆ‘ä»¬å¾ˆéš¾ç”¨ä¸€å¼ çº¹ç†åŒºåˆ†æ­£åé¢ï¼ˆå› ä¸ºæ˜¯å•å±‚å‡ ä½•ä½“ï¼‰ã€‚
    // æœ€å¥½çš„åŠæ³•ï¼šè‡ªå®šä¹‰ ShaderMaterialï¼Œæ ¹æ® gl_FrontFacing å†³å®šé¢œè‰²ã€‚
    
    const beltMaterial = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
        uniforms: {
            colorFront: { value: new THREE.Color(0x4488ff) }, // è“è‰²
            colorBack: { value: new THREE.Color(0xff4444) }   // çº¢è‰²
        },
        vertexShader: `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
                vUv = uv;
                vNormal = normal;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 colorFront;
            uniform vec3 colorBack;
            varying vec3 vNormal;
            void main() {
                if (gl_FrontFacing) {
                    gl_FragColor = vec4(colorFront, 1.0);
                } else {
                    gl_FragColor = vec4(colorBack, 1.0);
                }
                // ç®€å•çš„å…‰ç…§æ¨¡æ‹Ÿ
                // float light = dot(normalize(vec3(1.0, 1.0, 1.0)), vNormal); 
                // gl_FragColor.rgb *= (0.5 + 0.5 * light);
            }
        `
    });

    const belt = new THREE.Mesh(beltGeo, beltMaterial);
    // å°†å¸¦å­å±…ä¸­æ”¾ç½®ï¼Œè¿æ¥ä¸¤ä¸ªæ–¹å—
    // é»˜è®¤ Plane æ˜¯ç«–ç€çš„ï¼Œæˆ‘ä»¬æ—‹è½¬ä¸€ä¸‹è®©å®ƒå¹³èºº
    // å®é™…ä¸Šæˆ‘ä»¬åœ¨ updateBelt å‡½æ•°é‡Œä¼šå®Œå…¨é‡å†™é¡¶ç‚¹ä½ç½®ï¼Œæ‰€ä»¥è¿™é‡Œçš„åˆå§‹ä½ç½®ä¸é‡è¦
    scene.add(belt);

    // --- æ§åˆ¶é€»è¾‘ ---
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // çŠ¶æ€å˜é‡
    let currentAngleDeg = 0;
    let isUntangling = false;
    let untangleTime = 0; // 0 åˆ° 1
    
    const slider = document.getElementById('angle-slider');
    const angleDisplay = document.getElementById('angle-display');
    const btn = document.getElementById('untangle-btn');
    const animStatus = document.getElementById('anim-status');

    slider.addEventListener('input', (e) => {
        if (isUntangling) return; // åŠ¨ç”»ä¸­ç¦æ­¢æ‰‹åŠ¨æ“ä½œ
        currentAngleDeg = parseFloat(e.target.value);
        angleDisplay.textContent = currentAngleDeg;
        updateUIState();
        updateBelt();
    });

    btn.addEventListener('click', () => {
        if (currentAngleDeg >= 710) { // å…è®¸ä¸€ç‚¹è¯¯å·®
            startUntangleAnimation();
        }
    });

    function updateUIState() {
        // åªæœ‰æ¥è¿‘ 720 åº¦æ—¶æ‰å…è®¸è§£ç»“
        if (currentAngleDeg >= 710) {
            btn.disabled = false;
            btn.style.opacity = "1";
            btn.innerHTML = "âœ¨ æ‰§è¡Œæ‹“æ‰‘è¿˜åŸ (Untangle) âœ¨";
        } else {
            btn.disabled = true;
            btn.style.opacity = "0.5";
            btn.innerHTML = "ğŸ”’ éœ€æ—‹è½¬è‡³ 720Â° è§£é”è¿˜åŸæ¼”ç¤º";
        }
    }

    // --- æ ¸å¿ƒæ•°å­¦é€»è¾‘ï¼šæ›´æ–°å¸¦å­é¡¶ç‚¹ ---
    
    function updateBelt() {
        const positions = belt.geometry.attributes.position;
        const totalAngle = THREE.MathUtils.degToRad(currentAngleDeg);
        
        // æˆ‘ä»¬åœ¨ -3 (fixed) åˆ° +3 (rotating) ä¹‹é—´æ’å€¼
        const startX = -2.5;
        const endX = 2.5;
        const length = endX - startX;

        // æ—‹è½¬æ–¹å—æœ¬èº«
        rotatingBox.rotation.x = totalAngle;

        for (let i = 0; i <= segments; i++) {
            // u: å½’ä¸€åŒ–è¿›åº¦ (0 åˆ° 1)
            const u = i / segments;
            
            // å½“å‰åˆ‡ç‰‡åœ¨ X è½´çš„åŸºç¡€ä½ç½®
            let x = startX + u * length;
            let y = 0;
            let z = 0;

            // --- æ‹“æ‰‘è¿˜åŸåŠ¨ç”»é€»è¾‘ (The Belt Trick) ---
            // å½“æˆ‘ä»¬å¤„äºâ€œè§£ç»“â€æ¨¡å¼æ—¶ï¼Œæˆ‘ä»¬ä¸ä»…æ”¹å˜æ—‹è½¬è§’åº¦ï¼Œè¿˜å¿…é¡»ç§»åŠ¨å¸¦å­çš„è·¯å¾„ï¼ˆä¸­å¿ƒçº¿ï¼‰ã€‚
            // è¿™ç§ç§»åŠ¨éœ€è¦æŠŠå¸¦å­ä»ä¸­è·¯â€œæèµ·æ¥â€ï¼Œç»•è¿‡å³è¾¹çš„æ–¹å—ã€‚
            
            // åŸºç¡€æ‰­è½¬è§’åº¦ (çº¿æ€§åˆ†å¸ƒ)
            let twist = u * totalAngle;

            if (isUntangling) {
                // untangleTime ä» 0 èµ°å‘ 1
                const t = untangleTime;
                
                // 1. è·¯å¾„å˜å½¢ (Path Deformation)
                // æˆ‘ä»¬ä½¿ç”¨æ­£å¼¦æ³¢è®©å¸¦å­æ‹±èµ·æ¥ã€‚
                // åªæœ‰ä¸­é—´éƒ¨åˆ†æ‹±èµ·ï¼Œä¸¤ç«¯ä¸åŠ¨ã€‚
                // å½“ t=0.5 æ—¶æ‹±å¾—æœ€é«˜ã€‚
                const arcHeight = Math.sin(t * Math.PI) * 4.0; // æ‹±èµ·é«˜åº¦
                
                // è·¯å¾„åç§»ï¼šä¸ä»…å‘ä¸Š(Y)ï¼Œè¿˜è¦å‘å¤–(Z)ï¼Œå½¢æˆä¸€ä¸ªç»•è¿‡éšœç¢çš„å¼§çº¿
                // æˆ‘ä»¬è®©å®ƒç»•ç€å³ç«¯ç‚¹è½¬ã€‚
                // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„è§†è§‰è¿‘ä¼¼ï¼Œæ•°å­¦ä¸Šè¿™å¯¹åº”åŒä¼¦å˜æ¢ã€‚
                
                // ä½¿ç”¨ä¸€ä¸ªå¹³æ»‘çš„é’Ÿå½¢æ›²çº¿åªå½±å“å¸¦å­ä¸­é—´
                const envelope = Math.sin(u * Math.PI); 
                
                // å…³é”®ï¼šå¸¦å­çš„ä¸­å¿ƒçº¿éšç€æ—¶é—´ t ç»•ç€è½´å¿ƒè½¬åŠ¨
                // è¿™æ¨¡æ‹Ÿäº†â€œæŠŠå¸¦å­ä»åº•éƒ¨æèµ·æ¥ç¿»è¿‡å»â€çš„åŠ¨ä½œ
                const orbitAngle = t * Math.PI * 2; // 0 -> 2PI ç»•ä¸€åœˆ
                
                // è¿™é‡Œçš„æ•°å­¦æ¯”è¾ƒtrickyã€‚ä¸ºäº†è§†è§‰æ¼”ç¤ºï¼Œæˆ‘ä»¬æ··åˆä¸¤ç§çŠ¶æ€ï¼š
                // çŠ¶æ€A: æ‰­æ›²çš„ç›´çº¿ (t=0)
                // çŠ¶æ€B: æ²¡æ‰­æ›²çš„ç›´çº¿ (t=1)
                // ä¸­é—´è¿‡ç¨‹: å¸¦å­å¿…é¡»è¦ç»•å¤§åœˆã€‚
                
                // è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªæ›´ç›´è§‚çš„â€œå‚æ•°åŒ–â€æ–¹æ³•ï¼š
                // éšç€ t å¢åŠ ï¼Œæˆ‘ä»¬å°†ä¸€éƒ¨åˆ† twist "æ¨" å‡ºå»ï¼Œè½¬åŒ–ä¸ºè·¯å¾„çš„ç¯ç»•æ•°ã€‚
                
                // åŠ¨æ€è°ƒæ•´ twist: 
                // ç›®æ ‡æ˜¯è®© finalTwist å˜æˆ 0 (æˆ–è€… 4pi, ç­‰ä»·äº 0)
                // å®é™…ä¸Šè§†è§‰ä¸Šæˆ‘ä»¬éœ€è¦å®ƒå˜å¹³ã€‚
                // ç®€å•çš„çº¿æ€§æ’å€¼ä¼šè®©å¸¦å­åœ¨ä¸­é—´æ‰“ç»“ç©¿æ¨¡ã€‚
                // æ­£ç¡®çš„ Dirac Trick æ˜¯ï¼šå¸¦å­ä½œä¸ºä¸€ä¸ªæ•´ä½“æ‰«è¿‡æ–¹å—ã€‚
                
                // ç®€æ˜“æ¨¡æ‹Ÿæ–¹æ¡ˆï¼š
                // 1. è·¯å¾„åç§»ï¼šä»¥ X è½´ä¸ºä¸­å¿ƒï¼ŒåŠå¾„ä¸º R çš„èºæ—‹ã€‚
                const r = envelope * arcHeight; 
                // åç§»æ–¹å‘
                const offsetAngle = -t * Math.PI; // è¿™ç§æ—‹è½¬æ–¹å‘é…åˆ
                
                y += r * Math.cos(offsetAngle);
                z += r * Math.sin(offsetAngle);
                
                // 2. æ‰­è½¬æ¶ˆé™¤
                // éšç€å¸¦å­åœ¨ç©ºé—´ä¸­â€œç¿»è½¬â€ï¼Œå±€éƒ¨çš„ twist è¢«æŠµæ¶ˆäº†ã€‚
                // æˆ‘ä»¬ç®€å•åœ°çº¿æ€§æ’å€¼ twist è§’åº¦ä» 4PI åˆ° 0
                twist = u * (totalAngle * (1 - t)); 
                
                // ä¿®æ­£ï¼šä»…ä»…å‡å° twist æ˜¯ä¸å¤Ÿçš„ï¼Œå¸¦å­æ–¹å‘ä¹Ÿè¦è·Ÿç€è·¯å¾„è½¬ã€‚
                // ä¸ºäº†ä¿æŒå¸¦å­è¡¨é¢æ³•çº¿è¿ç»­ï¼Œæˆ‘ä»¬éœ€è¦æŠŠè·¯å¾„çš„æ—‹è½¬åŠ åˆ° twist ä¸Šã€‚
                // è¿™æ­£æ˜¯ Spinor çš„å‡ ä½•æœ¬è´¨ï¼šè·¯å¾„æ—‹è½¬å’Œè‡ªæ—‹çš„è€¦åˆã€‚
                twist += u * (t * 4 * Math.PI); // è¿™æ˜¯ä¸€ä¸ª trickï¼Œä¿æŒè§†è§‰ä¸Šçš„è¿ç»­æ€§
                
                // å®é™…ä¸Šï¼Œä¸ºäº†æ¼”ç¤ºæ•ˆæœæœ€å¹³æ»‘ï¼Œæˆ‘ä»¬é€šå¸¸ä½œå¼Šä¸€ä¸‹ï¼š
                // å½“ t ä» 0 åˆ° 1ï¼š
                // ç‰©ç†è§’åº¦ä» 720 é™åˆ° 0
                // åŒæ—¶è·¯å¾„åšä¸€ä¸ª 360 åº¦çš„ç¿»è½¬åŠ¨ä½œã€‚
            }

            // è®¡ç®—å½“å‰åˆ‡ç‰‡çš„ä¸¤ä¸ªé¡¶ç‚¹ (ä¸Šå’Œä¸‹)
            // å›´ç»• (1, 0, 0) è½´æ—‹è½¬
            const cos = Math.cos(twist);
            const sin = Math.sin(twist);

            // åŸå§‹å®½åº¦åç§» (Yè½´æ–¹å‘)
            const w = beltWidth / 2;

            // é¡¶ç‚¹ 1 (y+, z+) -> æ—‹è½¬å
            const y1 = w * cos;
            const z1 = w * sin;

            // é¡¶ç‚¹ 2 (y-, z-) -> æ—‹è½¬å
            const y2 = -w * cos;
            const z2 = -w * sin;

            // å†™å…¥ BufferGeometry
            // ä¸€ä¸ª segment æœ‰ä¸¤ä¸ªç‚¹ (ä¸Šå’Œä¸‹)ï¼Œå¯¹åº” PlaneGeometry çš„åˆ—
            // PlaneGeometry çš„é¡¶ç‚¹é¡ºåºæ˜¯è¡Œä¼˜å…ˆï¼Œè¿˜æ˜¯åˆ—ä¼˜å…ˆï¼Ÿ
            // Three.js PlaneGeometry (width, height, wSeg, hSeg)
            // é¡¶ç‚¹å­˜å‚¨é¡ºåºï¼šä»å·¦ä¸Šè§’å¼€å§‹ï¼Œä¸€è¡Œä¸€è¡Œå­˜ã€‚
            // æˆ‘ä»¬çš„ belt æ˜¯æ¨ªç€çš„ï¼Œwidth æ˜¯é•¿ï¼Œheight æ˜¯å®½ã€‚
            // åªæœ‰ 1 ä¸ª height segmentï¼Œä¹Ÿå°±æ˜¯åªæœ‰ä¸¤è¡Œé¡¶ç‚¹ã€‚
            // ç¬¬ä¸€è¡Œï¼šy = +w, ç¬¬äºŒè¡Œï¼šy = -w
            
            // ç´¢å¼•è®¡ç®—ï¼š
            // ç¬¬ i åˆ—ï¼Œç¬¬ 0 è¡Œ (Top vertex)
            const idx1 = i; 
            // ç¬¬ i åˆ—ï¼Œç¬¬ 1 è¡Œ (Bottom vertex)
            const idx2 = i + (segments + 1);

            // è®¾ç½®ä½ç½®ï¼šåŠ ä¸Šä¸­å¿ƒçº¿åç§» (x, y, z)
            positions.setXYZ(idx1, x, y + y1, z + z1);
            positions.setXYZ(idx2, x, y + y2, z + z2);
        }

        positions.needsUpdate = true;
        belt.geometry.computeVertexNormals();
    }

    function startUntangleAnimation() {
        if (isUntangling) return;
        isUntangling = true;
        untangleTime = 0;
        animStatus.textContent = ">>> æ­£åœ¨æ‰§è¡ŒåŒä¼¦å˜æ¢ (Homotopy) <<<";
        
        // ç¦ç”¨ Slider
        slider.disabled = true;
        
        // åŠ¨ç”»å¾ªç¯
        const startTime = performance.now();
        const duration = 4000; // 4ç§’æ…¢åŠ¨ä½œæ¼”ç¤º

        function animateUntangle(time) {
            const elapsed = time - startTime;
            let progress = elapsed / duration;
            
            if (progress > 1) progress = 1;
            
            // ä½¿ç”¨ç¼“åŠ¨å‡½æ•° easeInOut
            untangleTime = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

            updateBelt();

            if (progress < 1) {
                requestAnimationFrame(animateUntangle);
            } else {
                // åŠ¨ç”»ç»“æŸ
                isUntangling = false;
                untangleTime = 0;
                // é‡ç½®çŠ¶æ€ï¼šç°åœ¨å¸¦å­æ˜¯ç›´çš„äº†ï¼Œæˆ‘ä»¬åœ¨é€»è¾‘ä¸Šä¹ŸæŠŠå®ƒé‡ç½®ä¸º0åº¦
                currentAngleDeg = 0; 
                slider.value = 0;
                slider.disabled = false;
                angleDisplay.textContent = "0 (å·²è¿˜åŸ)";
                rotatingBox.rotation.x = 0;
                updateBelt(); // ç»˜åˆ¶æœ€åçš„ä¸€å¸§
                updateUIState();
                animStatus.textContent = ">>> è¿˜åŸå®Œæˆï¼š720Â° â‰… 0Â° <<<";
            }
        }
        
        requestAnimationFrame(animateUntangle);
    }

    // --- æ¸²æŸ“å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (!isUntangling) {
            // å¦‚æœä¸åœ¨åŠ¨ç”»ä¸­ï¼Œä¿æŒå¸¸è§„æ›´æ–°ï¼ˆé˜²æ­¢ç©¿æ¨¡æˆ–å¾®è°ƒï¼‰
            updateBelt(); 
        }
        renderer.render(scene, camera);
    }

    // åˆå§‹åŒ–ç»˜åˆ¶
    updateBelt();
    animate();

    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>