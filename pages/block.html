<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>核物理：堵塞效应演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        h2 { margin-bottom: 10px; }
        .canvas-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
        }
        canvas {
            background: linear-gradient(to bottom, #2b32b2, #1488cc); /* 深蓝背景 */
            display: block;
        }
        .controls {
            margin-top: 20px;
            background: #333;
            padding: 15px;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background 0.3s;
            font-weight: bold;
        }
        .btn-normal { background-color: #4CAF50; color: white; }
        .btn-normal:hover { background-color: #45a049; }
        .btn-block { background-color: #ff9800; color: white; }
        .btn-block:hover { background-color: #e68a00; }
        
        .status-text {
            margin-top: 15px;
            font-size: 1.1em;
            color: #ddd;
            max-width: 600px;
            text-align: center;
            line-height: 1.5;
        }
        .legend {
            display: flex;
            gap: 15px;
            font-size: 0.9em;
            margin-top: 5px;
        }
        .dot { width: 10px; height: 10px; display: inline-block; border-radius: 50%; margin-right: 5px; }
    </style>
</head>
<body>

    <h2>堵塞效应 (Blocking Effect) 可视化</h2>

    <div class="canvas-container">
        <canvas id="simCanvas" width="600" height="400"></canvas>
    </div>

    <div class="controls">
        <button class="btn-normal" onclick="setMode('normal')">偶偶核 (超导态)</button>
        <button class="btn-block" onclick="setMode('blocking')">奇质量核 (堵塞态)</button>
    </div>

    <div class="legend">
        <span><span class="dot" style="background: #ff4d4d;"></span>自旋上</span>
        <span><span class="dot" style="background: #4d4dff;"></span>自旋下</span>
        <span><span class="dot" style="background: #ffd700;"></span>未配对奇核子 (堵塞者)</span>
    </div>

    <div class="status-text" id="description">
        当前状态：<b>偶偶核</b><br>
        核子形成库珀对，并在所有能级之间自由散射。系统具有时间反演对称性。
    </div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const descText = document.getElementById('description');

    // 配置参数
    const numLevels = 5;
    const levelSpacing = 60;
    const startY = 80;
    const particleRadius = 12;
    
    // 状态变量
    let isBlockingMode = false;
    let particles = [];
    let levels = []; // 存储每个能级是否被占用 {y: number, occupied: boolean, blocked: boolean}

    // 初始化能级
    for(let i=0; i<numLevels; i++) {
        levels.push({
            y: startY + i * levelSpacing,
            occupied: false,
            blocked: false 
        });
    }

    class Particle {
        constructor(levelIndex, type, offset) {
            this.levelIndex = levelIndex;
            this.type = type; // 'up' (red), 'down' (blue), or 'odd' (gold)
            this.offset = offset; // x position offset relative to center
            
            // 动画位置
            this.x = canvas.width / 2 + offset;
            this.y = levels[levelIndex].y;
            this.targetY = this.y;
        }

        update() {
            // 简单的插值动画，让粒子平滑移动到目标能级
            const dy = this.targetY - this.y;
            this.y += dy * 0.1;
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, particleRadius, 0, Math.PI * 2);
            if (this.type === 'up') ctx.fillStyle = '#ff4d4d';
            else if (this.type === 'down') ctx.fillStyle = '#4d4dff';
            else ctx.fillStyle = '#ffd700'; // Gold for odd particle
            
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // 绘制箭头表示自旋
            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            if (this.type === 'up' || (this.type === 'odd' && Math.random() > 0.5)) { // 奇核子自旋这里简单模拟
                ctx.moveTo(this.x, this.y + 5);
                ctx.lineTo(this.x, this.y - 5);
                ctx.lineTo(this.x - 3, this.y - 2);
            } else {
                ctx.moveTo(this.x, this.y - 5);
                ctx.lineTo(this.x, this.y + 5);
                ctx.lineTo(this.x - 3, this.y + 2);
            }
            ctx.stroke();
        }
    }

    // 初始化粒子系统
    function initParticles() {
        particles = [];
        // 清除能级占用状态
        levels.forEach(l => { l.occupied = false; l.blocked = false; });

        if (!isBlockingMode) {
            // 偶偶核模式：放置2对
            spawnPair(1); // 放在第2层
            spawnPair(3); // 放在第4层
        } else {
            // 堵塞模式
            // 1. 放置奇核子在中间层 (Index 2)
            const oddP = new Particle(2, 'odd', 0);
            particles.push(oddP);
            levels[2].occupied = true;
            levels[2].blocked = true;

            // 2. 放置1对在其他层
            spawnPair(0); // 放在第1层
        }
    }

    function spawnPair(levelIdx) {
        particles.push(new Particle(levelIdx, 'up', -20));
        particles.push(new Particle(levelIdx, 'down', 20));
        levels[levelIdx].occupied = true;
    }

    // 模拟散射过程（核心逻辑）
    function scatter() {
        // 找出所有配对的粒子（排除奇核子）
        const pairs = [];
        const pairMap = {}; // 辅助归类
        
        particles.forEach(p => {
            if (p.type !== 'odd') {
                if (!pairMap[p.levelIndex]) pairMap[p.levelIndex] = [];
                pairMap[p.levelIndex].push(p);
            }
        });

        // 只有成对的才能散射
        for (const idx in pairMap) {
            if (pairMap[idx].length === 2) pairs.push(pairMap[idx]);
        }

        if (pairs.length === 0) return;

        // 随机选择一对进行跃迁
        const movingPair = pairs[Math.floor(Math.random() * pairs.length)];
        const currentLevelIdx = movingPair[0].levelIndex;

        // 寻找空闲能级
        const availableLevels = [];
        for (let i = 0; i < numLevels; i++) {
            // 关键逻辑：
            // 1. 目标层不能已经被占用
            // 2. 如果是堵塞模式，目标层不能是被堵塞的那一层
            if (!levels[i].occupied && (!isBlockingMode || i !== 2)) {
                availableLevels.push(i);
            }
        }

        // 如果有空位，进行跳跃
        if (availableLevels.length > 0) {
            const targetIdx = availableLevels[Math.floor(Math.random() * availableLevels.length)];
            
            // 更新状态
            levels[currentLevelIdx].occupied = false;
            levels[targetIdx].occupied = true;

            movingPair.forEach(p => {
                p.levelIndex = targetIdx;
                p.targetY = levels[targetIdx].y;
            });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制能级线
        levels.forEach((level, index) => {
            ctx.beginPath();
            ctx.moveTo(100, level.y);
            ctx.lineTo(500, level.y);
            
            if (level.blocked) {
                ctx.strokeStyle = '#ff9800'; // 堵塞层用橙色
                ctx.lineWidth = 4;
                ctx.setLineDash([5, 5]); // 虚线表示被破坏/占据
            } else {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
            }
            ctx.stroke();

            // 绘制文字标记
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.font = '14px Arial';
            if (level.blocked) {
                ctx.fillStyle = '#ff9800';
                ctx.fillText(`能级 ${index + 1} (BLOCKED)`, 20, level.y + 5);
            } else {
                ctx.fillText(`能级 ${index + 1}`, 20, level.y + 5);
            }
        });

        // 绘制粒子
        particles.forEach(p => {
            p.update();
            p.draw();
        });

        requestAnimationFrame(draw);
    }

    function setMode(mode) {
        if (mode === 'normal') {
            isBlockingMode = false;
            descText.innerHTML = "当前状态：<b>偶偶核 (Normal)</b><br>核子形成库珀对（红/蓝），它们可以在<b>所有</b>能级之间自由跳跃（散射）。这就是超导/超流性的来源。";
        } else {
            isBlockingMode = true;
            descText.innerHTML = "当前状态：<b>奇核 (Blocking)</b><br>一个未配对的奇核子（金色）<b>霸占</b>了中间的能级（泡利不相容）。<br>注意观察：其他配对的核子<b>无法跳跃到该能级</b>。由于可用的散射通道减少，配对关联减弱。";
        }
        initParticles();
    }

    // 启动
    initParticles();
    draw();
    
    // 定时触发散射事件
    setInterval(scatter, 800); // 每0.8秒尝试一次散射

</script>

</body>
</html>