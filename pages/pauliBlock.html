---
layout: page
title: 核物理：堵塞效应演示
permalink: /pauli-block/
---

<style>
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #1a1a1a;
        color: #eee;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
    }
    h2 { margin-bottom: 10px; }
    .canvas-container {
        position: relative;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
        border-radius: 8px;
        overflow: hidden;
    }
    canvas {
        background: linear-gradient(to bottom, #2b32b2, #1488cc);
        display: block;
    }
    .controls {
        margin-top: 20px;
        background: #333;
        padding: 15px;
        border-radius: 8px;
        display: flex;
        gap: 15px;
        align-items: center;
    }
    button {
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        transition: background 0.3s;
        font-weight: bold;
    }
    .btn-normal { background-color: #4CAF50; color: white; }
    .btn-normal:hover { background-color: #45a049; }
    .btn-block { background-color: #ff9800; color: white; }
    .btn-block:hover { background-color: #e68a00; }
    
    .status-text {
        margin-top: 15px;
        font-size: 1.1em;
        color: #ddd;
        max-width: 600px;
        text-align: center;
        line-height: 1.5;
    }
    .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-top: 10px;
        color: #bbb;
        font-size: 14px;
    }
    .legend span {
        display: flex;
        align-items: center;
        gap: 6px;
    }
    .dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
    }
    .dot.red { background: #ff5252; }
    .dot.blue { background: #40c4ff; }
    .dot.gold { background: #ffd54f; }
</style>

<div class="page-pauli-block">
    <h2>堵塞效应演示（Pauli Blocking）</h2>
    <div class="canvas-container">
        <canvas id="canvas" width="400" height="400"></canvas>
    </div>
    <div class="controls">
        <button class="btn-normal" onclick="setMode('normal')">偶偶核（无堵塞）</button>
        <button class="btn-block" onclick="setMode('blocking')">奇核（有堵塞）</button>
    </div>
    <div class="legend">
        <span><span class="dot red"></span> 红：自旋向上</span>
        <span><span class="dot blue"></span> 蓝：自旋向下</span>
        <span><span class="dot gold"></span> 金色：未配对核子（堵塞）</span>
    </div>
    <div id="status" class="status-text">
        当前状态：<b>偶偶核 (Normal)</b><br>
        核子形成库珀对（红/蓝），它们可以在所有能级之间自由跳跃（散射）。这就是超导/超流性的来源。
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');

    const levels = [
        { y: 80, particles: [] },
        { y: 200, particles: [] },
        { y: 320, particles: [] },
    ];

    let particles = [];
    let mode = 'normal';
    let isBlockingMode = false;

    function initParticles() {
        particles = [];
        levels.forEach(l => l.particles = []);

        if (mode === 'normal') {
            for (let i = 0; i < 6; i++) {
                const spinUp = i % 2 === 0;
                const p = createParticle(spinUp);
                particles.push(p);
            }
        } else {
            for (let i = 0; i < 5; i++) {
                const spinUp = i % 2 === 0;
                const p = createParticle(spinUp);
                particles.push(p);
            }
            const blocker = createParticle(true);
            blocker.level = 1;
            blocker.targetY = levels[1].y;
            blocker.color = '#ffd54f';
            blocker.blocker = true;
            levels[1].particles.push(blocker);
            particles.push(blocker);
        }

        // assign random levels
        particles.forEach(p => {
            if (p.blocker) return;
            const levelIdx = Math.floor(Math.random() * levels.length);
            p.level = levelIdx;
            p.targetY = levels[levelIdx].y;
            levels[levelIdx].particles.push(p);
        });
    }

    function createParticle(spinUp) {
        return {
            x: 200 + (Math.random() * 120 - 60),
            y: Math.random() * 400,
            targetY: 200,
            level: 1,
            spinUp,
            color: spinUp ? '#ff5252' : '#40c4ff',
            blocker: false
        };
    }

    function drawLevels() {
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        levels.forEach(l => {
            ctx.beginPath();
            ctx.moveTo(60, l.y);
            ctx.lineTo(340, l.y);
            ctx.stroke();
        });
    }

    function drawParticles() {
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
            ctx.fill();

            if (p.blocker) {
                ctx.strokeStyle = '#ffd54f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
                ctx.stroke();
            }
        });
    }

    function scatter() {
        particles.forEach(p => {
            if (p.blocker) return;

            if (mode === 'blocking') {
                if (levels[p.level] === levels[1]) {
                    // blocked level, skip scatter in blocking mode
                    return;
                }
            }

            let newLevel = Math.floor(Math.random() * levels.length);
            if (mode === 'blocking') {
                while (newLevel === 1) newLevel = Math.floor(Math.random() * levels.length);
            }
            p.level = newLevel;
            p.targetY = levels[newLevel].y;
            p.x = 200 + (Math.random() * 120 - 60);
        });
    }

    function updateParticles() {
        particles.forEach(p => {
            p.y += (p.targetY - p.y) * 0.08;
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLevels();
        updateParticles();
        drawParticles();
        requestAnimationFrame(draw);
    }

    function setMode(m) {
        mode = m;
        const blocking = mode === 'blocking';
        isBlockingMode = blocking;
        initParticles();
        if (blocking) {
            statusEl.innerHTML = "当前状态：<b>奇核 (Blocking)</b><br>一个未配对的奇核子（金色）霸占了中间的能级（泡利不相容）。注意：其他配对核子无法跳跃到该能级，配对关联减弱。";
        } else {
            statusEl.innerHTML = "当前状态：<b>偶偶核 (Normal)</b><br>核子形成库珀对（红/蓝），它们可以在所有能级之间自由跳跃（散射）。这就是超导/超流性的来源。";
        }
    }

    initParticles();
    draw();
    setInterval(scatter, 800);
</script>
